# spring-cgv-22nd
CEOS 22기 백엔드 스터디 - CGV 클론 코딩 프로젝트

## 2주차 미션

### ERD
<img width="1830" height="1112" alt="CGV_HY" src="https://github.com/user-attachments/assets/32dd7a3b-e0aa-42bc-bfed-e4b7761a9fa8" />


### 설명
1. 영화관 & 상영관

   영화관(theater)은 이름과 주소를 가지고 있고, 그 안에는 여러 개의 상영관(screen)이 존재합니다.
   상영관은 일반관, 특별관 같은 타입을 구분할 수 있도록 하고, 좌석 수는 row_count와 col_count로 저장했습니다.
   처음에는 좌석을 아예 별도의 테이블로 관리할까 고민했지만, 특별관/일반관 모두 같은 직사각형 구조이고 속성이 단순해서 굳이 테이블을 분리하지 않아도 된다고 판단했습니다.

3. 예매 & 좌석

   예매(reservation)는 사용자가 특정 상영정보를 선택해 예약한 기록을 담습니다.
   문제는 한 번에 좌석을 여러 개 예약할 수 있다는 점이었는데, 이를 해결하기 위해 reservation_seat 테이블을 따로 두었습니다.
   이 안에는 예약 ID와 함께 row, col 좌표가 들어갑니다.
   이렇게 하면 동시 예약 상황에서도 좌석 단위로 관리할 수 있어 충돌을 줄일 수 있을거라 생각했습니다.

5. 매점

   매점(snack_menu)에는 상품명, 가격, 카테고리가 저장됩니다.
   재고는 처음에는 전역으로 관리할까 했지만, 지점마다 재고 상황이 다를 수 있어서 snack_inventory 테이블을 만들어 영화관별로 분리했습니다.
   사용자가 매점을 이용하면 snack_order가 생기고, 어떤 상품을 몇 개 샀는지는 order_detail에 기록됩니다.

<br><br>

### swagger 캡처 화면
<img width="1312" height="926" alt="KakaoTalk_Photo_2025-09-21-오후 8-23-19" src="https://github.com/user-attachments/assets/f14a8d8d-2dd9-40dd-888f-a8e305dc8f1f" />

## 3주차 미션

### 1)  쿠키(Cookie)

1. 개념
- 클라이언트의 브라우저에 저장되는 키-값 형태의 데이터입니다.
- 상태 유지가 필요할 때 서버가 클라이언트에게 전달하며, 클라이언트는 이후의 요청에서 이 데이터를 자동으로 서버에 전송합니다.

2. 특징
- 클라이언트 측 저장
- 만료 시간 설정 가능
- 브라우저 종료 후에도 유지 가능 (만료 시간에 따라)

3. 주요 구성 요소
- 이름(name), 값(value), 유효기간(Expires)
- 전송할 도메인(Domain)과 경로(Path)

4. 활용 예시
- 자동 로그인 (아이디 저장)
- 장바구니 데이터 유지


### 2) 세션(Session)

1. 개념
- 서버가 사용자별로 상태를 저장하고 관리하는 방식입니다.
- 서버는 클라이언트에게 고유한 세션 ID를 부여하며, 클라이언트는 이를 쿠키에 저장해 매 요청마다 서버로 전달합니다.

2. 특징
- 서버 측 저장
- 클라이언트 수가 많아지면 서버 자원 사용 증가
- 보안적으로 쿠키보다 안전함 (세션은 서버에서만 조작 가능)

3. 활용 예시
- 로그인 상태 유지

4. 다중 서버 환경에서의 세션 관리
- **Sticky Session**: 특정 사용자의 요청을 항상 동일한 서버로 전달
- **Session Clustering**: 모든 서버가 동일한 세션 정보를 공유
- **Session Storage**: Redis나 DB 등을 활용하여 세션을 중앙 집중식으로 관리

### 3) 토큰 기반 인증 (Token-based Authentication)

세션 방식은 서버 자원을 많이 소모하기 때문에, **토큰 기반 인증** 방식이 많이 활용됩니다.

1. 개념
- 서버가 클라이언트에게 고유 토큰을 발급하고, 클라이언트는 이후 요청마다 이 토큰을 헤더에 담아 전달합니다.
- 서버는 토큰의 유효성과 위변조 여부를 검증하여 인증을 처리합니다.

2. 특징
- 클라이언트에 저장됨으로 서버의 메모리 부담이 적음
- 서버는 Stateless 하게 동작 가능


### 4) JWT (JSON Web Token)

1. 개념
- 사용자 정보를 JSON 형태로 담아 인코딩한 토큰입니다.
- `.`을 기준으로 나뉜 세 부분으로 구성됩니다: **Header**, **Payload**, **Signature**

2. 구조
1. **Header**: 토큰 타입과 해시 알고리즘
2. **Payload**: 사용자 및 기타 데이터 (Claim)
3. **Signature**: 비밀키로 서명한 값으로 위변조 방지

3. 장점
- 자체적으로 필요한 정보를 포함 (Self-contained)
- 서버에 상태를 저장하지 않아도 됨
- Signature로 위조 여부 검증 가능



### 5) Access Token & Refresh Token

1. Access Token
- 서버가 인증에 성공한 클라이언트에게 발급
- 짧은 유효기간을 가지며 요청 시 포함되어 인증 처리됨
- Stateless 하므로 서버는 따로 저장하지 않음

2. Refresh Token
- Access Token의 단점을 보완하기 위해 함께 발급됨
- 유효기간이 길고, Access Token이 만료됐을 때 이를 통해 재발급 요청 가능
- 보안을 위해 서버에 저장되어 관리됨

3. 장점
- 탈취 시에도 유효기간이 짧아 피해 최소화 가능
- 유저 강제 로그아웃 또는 토큰 만료 구현 가능

4. 단점
- 서버에 저장소 필요 (세션 방식과 유사한 I/O 비용 발생)
- 클라이언트 구현이 복잡해짐 (재발급 로직 필요)



## 쿠키, 세션, 토큰 비교
| 항목        | 쿠키                        | 세션                     | 토큰 (JWT)            |
|-------------|-----------------------------|--------------------------|------------------------|
| 저장 위치   | 클라이언트                  | 서버                    | 클라이언트             |
| 보안성      | 낮음 (변조 가능)            | 높음 (서버 관리)         | 높음 (서명 기반 검증) |
| 서버 부담   | 없음                        | 있음                     | 없음                   |
| 속도        | 빠름                        | 느림                     | 빠름                   |
| 만료 제어   | 가능 (Expires 설정)         | 불명확                   | 가능 (Payload 내 설정) |
| 상태 관리   | O                           | O                        | X                      |
